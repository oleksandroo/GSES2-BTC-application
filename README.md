# GSES2-BTC-application
 
Вітаю! Ось моє виконання кейсового завдання в Software Engineering School. Нижче можна прочитати інструкцію та як я покроково виконував цей кейс


## Інструкція по встановленню

Я вважаю що ви її і так знаєте, але все ж вважаю за потрібним написати її
Додати відповідний домен в `hosts` файл:

```
127.0.0.1 http://gses2.app/
```

Клонувати репозиторій:

```
$ git clone https://github.com/oleksandroo/GSES2-BTC-application.git && cd GSES2-BTC-application
```

**Решта команд запускаються з кореня проекту.**

Скопіюйте `.env.example` до `.env` як у корені проекту, так і в `src/task`:

```
$ cp .env.example .env && cd src/task && cp .env.example .env && cd ../..
```

Встановіть залежності:

```
$ docker compose run --rm task composer install
```

Запустіть проект:

```
$ docker compose up -d
```

Після запуску проекту згенеруйте ключ Laravel:

```
$ docker compose exec task php artisan key:generate
```

##Виконання кейсу

###0. Підготовка до розробки
Розробку я проводив у WSL2 на базі Ubuntu 20.04 LTS (GNU/Linux 5.10.102.1-microsoft-standard-WSL2 x86_64), в якості IDE використовував PHPStorm і  Postman як API клієнт

Сам код я вирішив писати на РНР використовуючи фреймворк Laravel. Такий вибір обумовлений тим що РНР я доволі непогано знаю, а з Laravel хоч майже не працював і це був челендж для мене за досить короткий проміжок часу розібратись з ним, але знаю що реалізований функціонал для легшого і правильного написання АРІ

###1. Підготовка оточення
Основні моменти:
	- В завданні не згадувалось, але зробив docker-compose.yml файл щоб у разі необхідності можна було додати новий контейнер (з БД, наприклад), та і не вважав правильним впихати все в Dockerfile
	- Не використовував Laravel Sail, бо Sail призначений для програм, які повністю розроблені в Laravel, на відміну від програм, де Laravel це лише один з компонентів. Тому вирішив підключити Laravel як компонент, щоб можна було підключити й інші компоненти
	- В Dockerfile створив користувача task щоб контейнери не використовували користувача root 
	
Але тут я стикнувся з проблемою що ніяк не міг правильно налаштувати nginx і не міг отримати доступу до сайту за посиланням gses2.app, лише через localhost, яку так і не зміг вирішити. Тому в мене Base URL виглядає як localhost/api/

###2. Реалізація функціоналу
Перед тим як писати код, я уявив як має виглядати готовий код, в чому допоміг опис кейсового завдання.
У нас є дві сущності - rate (робота з курсом ВТС) і subscription (робота з підписками), які можна уявити як два різних контролери. В першому контролері є метод rate, а в другому два методи: subscribe і sendEmails. Ці ж методи використовують у своїй роботі різні сервіси - сервіс для роботи з HTTP запитами, сервіс для роботи з електронними адресами і сервіс для роботи з поштою
І вже відштовхуючись від цього почав реалізовувати відповідні контролери і сервіси
Тому перед реалізацією методів я створив відповідні контролери, прописав роути і перевірив чи все працює
![image](https://user-images.githubusercontent.com/109922489/181935250-31abe0f3-bf5f-4464-9a2f-634420ee4ea8.png)
####2.1. Реалізація методу rate
Для реалізації цього методу  мені спершу треба реалізувати сервіс який буде через публічний АРІ отримувати курс ВТС. В якості параметрів передається лінк за яким будем здійснювати запит і параметри

![image](https://user-images.githubusercontent.com/109922489/181935277-58d6c47b-2a0e-49be-9eb6-01928db8fbc2.png)
В контролері я передаю лінк (його зберіг у спеціально створеному файлі конфігурації task.php) і параметри, і натомість отримую відповідь і її передаю 

![image](https://user-images.githubusercontent.com/109922489/181935289-5e5bcf90-9da9-4a36-b61f-d152eaee3f9d.png)
І в результаті отримую поточний курс

![image](https://user-images.githubusercontent.com/109922489/181935311-db08a14b-c277-4375-a4a2-a47f36d8b2b5.png)
####2.2. Реалізація методу subscribe
Для цього створюю EmailService, який буде працювати з емейлами, і в ньому реалізовую метод addNewEmail, який зберігає передану пошту за вказаним шляхом, і повертає true якщо вдалось додати, і false якщо емейл вже був доданий раніше

![image](https://user-images.githubusercontent.com/109922489/181935320-69a8dec5-0d74-46e7-b8f5-0111d5d70a31.png)

І переконуюсь що все працює як треба
Перший запит

![image](https://user-images.githubusercontent.com/109922489/181935362-a7843439-2833-417a-89f7-2609a9dcb9fc.png)

Повторний запит

![image](https://user-images.githubusercontent.com/109922489/181935380-f637fe3a-5773-4cd7-8cc1-44b050b415e0.png)

2.3. Реалізація методу sendEmails
Для цього я спочатку реалізував метод getAllEmails в EmailService, який витягує всі емейли, або повертає null, якщо файлу не існує. 

![image](https://user-images.githubusercontent.com/109922489/181935390-b7ed3a7f-07d8-4871-97d6-b0917426dada.png)

Опісля реалізував сервіс EmailService, в якому реалізував власне відправку повідомлень. Для відправлення повідомлень я використав сервіс mailtrap.io, конфігурацію якого прописав в .env файлі, і також створив розмітку і клас RateMail похідний від Mailable

![image](https://user-images.githubusercontent.com/109922489/181935404-c36e0a44-51a3-4cbf-9aa1-4fb8fd7128b5.png)

І нарешті поєднав все у контролері

![image](https://user-images.githubusercontent.com/109922489/181935410-956f80e6-f8a2-493d-88c2-33de2f68d6fb.png)

Перевіряємо 

![image](https://user-images.githubusercontent.com/109922489/181935417-9ac65eec-175a-498c-b53d-ff8dbe1fa4fc.png)
![image](https://user-images.githubusercontent.com/109922489/181935427-d59350cf-1296-4153-81b4-92a5e17ed3f2.png)

